## Top Interview Questions (150)

|Difficulty | Problem  | Logic | Implementation Trick| LeetCode Number| SR. | 
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| Easy  |  1. Two Sum | HashMap<Sum,Index> & always clarify requirements  | |   | 1 |
| Easy  |  13. Roman to Integer | The logic here is that, if a current character value is greater than that of the previous, we have to subtract it. | |   | 2|
| Easy  |  14. Longest Common Prefix | Keep a boolean flag, break | |   | 3|
| Easy  |  20. Valid Parentheses | Use a Stack, push closing bracket for opening bracket | Stack stack = new Stack() |   | 4|
| Easy  |  21. Merge Two Sorted Lists | use a dummy node for pointing at head, use a copy of dummy node for appending and iterate till both list are not null  | |   | 5|
|  Easy |  26. Remove Duplicates from Sorted Array | Keep two indexes, track current element, track unique element index. | Handle the last element well and return start+1 |   | 6|
| Easy  | 28. Implement strStr()/indexOf() | Two loops compare each index (simulation) | |   | 7|
| Easy  |  66. Plus One | add carry if digit<9 return else return new array with 1 and all elements 0's  | |   | 8|
|  Easy |  69. Sqrt(x) | Simple Binary Search with lastFound pattern | |   | 9|
|  Easy | 70. Climbing Stairs  | Simple DP with HM | |   | 10|
|  Easy | 88. Merge Sorted Array  | Start from back of the larger array and compare greater elements first, fill the array and you are done  | |   | 11|
|  Easy |  94. Binary Tree Inorder Traversal | LNodeR | |   | 12|
|  Easy |  101. Symmetric Tree | Check for the node and recurse on left and right. | |  | 13|
|  Easy |  104. Maximum Depth of Binary Tree | max(depth(l)+depth(r)+1) | null-return 0 | |   | 14|
| Easy  |  108. Convert Sorted Array to Binary Search Tree | Take the mid element in sorted array and recurse on L & R, return null when start>end  | |   | 15|
| Easy  |  118. Pascal's Triangle |  | |  two loops, one go through the row, one go through the column & calculate element value: K(i)(j)=K(i-1)(j-1)+K(i-1)(j) except for the first and last element | 16|
|  Easy | 121. Best Time to Buy and Sell Stock  | maintain min_so_far, compute profit, maintain max_profit, return max_profit  | |   | 17|
|  Easy |  125. Valid Palindrome | Edge cases are tricky but doable (review code) | |   | 18|
| Easy  | 136. Single Number  | XOR all nums, result is ans| |   | 19|
| Easy  | 141. Linked List Cycle  | Fast and Slow Pointer Pattern | |   | 20|
| Easy  | 160. Intersection of Two Linked Lists  | Simple use a hashset | More optimized:1, Get the length of the two lists.2, Align them to the same start point.3, Move them together until finding the intersection point, or the end null  | |   | 21|
|  Easy |  163. Missing Ranges | SKIP | |   | 22|
| Easy  | 169. Majority Element (N/2) | Simple: HashMap, Optimized: Boyer-Moore Voting Algorithm: given that it is impossible (in both cases) to discard more majority elements than minority elements, we are safe in discarding the prefix and attempting to recursively solve the majority element problem for the suffix. Eventually, a suffix will be found for which count does not hit 0, and the majority element of that suffix will necessarily be the same as the majority element of the overall array. | keep a count, candidate, when count==0, change candidate else increment/decrement count.  |   | 23|
| Easy  | 171. Excel Sheet Column Number  |  Base 26 - compute number - nothing special| |   | 24|
| Easy  |  190. Reverse Bits | SKIP | |   | 25|
| Easy  | 191. Number of 1 Bits  | SKIP | |   | 26|
| Easy  |  202. Happy Number | HashSet for duplicates, simulation | |   | 27|
| Easy  |  206. Reverse Linked List | Iterative and Recursive (putPreAfterNode). (Review code) | |   | 28|
|  Easy |  217. Contains Duplicate | HashSet | |   | 29|
|  Easy |  234. Palindrome Linked List | Very tricky, you can do it in O(1) space with recursion. |(recurse till the end, global variable for front and then compare and return boolean flag) |   | 30|
| Easy  | 237. Delete Node in a Linked List (input: Only the node/not head node)  | Since we couldn't enter the preceding node, we can not delete the given node. We can just copy the next node to the given node and delete the next one | |   | 31|
| Easy  | 242. Valid Anagram  | Use alphabet character array | |   | 32|
| Easy  | 268. Missing Number  | Sum of 1..N=(N)(N+1)/2, subtract sum for ans | |   | 33|
| Easy   | 283. Move Zeroes  | Keep ignoring zeros, two indexes/ptrs, fill the rest of array with 0s  | |   | 34|
| Easy  |  326. Power of Three | Keep Dividing by 3 till not divisible, if ans is 1 then divisible by 3 else false |Time Complexity : O(log3(n)) |   | 35|
| Easy  |  344. Reverse String (Inplace) | recursion with last and start indexes as state | |   | 36|
| Easy  |  350. Intersection of Two Arrays II | TODO | |   | 37|
| Easy  |  387. First Unique Character in a String | Use HashMap or Character 26 array to track chars | |   | 38|
| Easy  | 412. Fizz Buzz  | Use StringBuilder & Simulate | |   | 39|


## Medium Questions (85)
|Difficulty | Problem  | Logic | Implementation Trick| LeetCode Number| SR. | 
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| Medium  | 2. Add Two Numbers  | Easy | Use dummyNode, Use frontNode(copy of dummy), iterate tille any list has node |   | 40|
|   | 3. Longest Substring Without Repeating Charact  |  Two Pointer with HashSet| |   | 41|
|   | 5. Longest Palindromic Substring  | Brute Force: consider Odd|Even Palidromes, for each index, keep extending till palidrome. Dynamic Programming Standard Problem | Loops are tricky as its looking at len=1 |   | 42|
|   | 7. Reverse Integer  |  rev= rev*10 + x % 10. To handle overflow: check prevRev and current element | |   | 43|
|   | 8. String to Integer (atoi)  | SKIP | |   | 44|
|   | 11. Container With Most Water  |  area formed between the lines will always be limited by the height of the shorter line. Further, the farther the lines, the more will be the area obtained | Two Pointer Approach, move the shorter line |   | 45|
|   | 15. 3Sum  | Sort and and do two way search.  |To avoid duplicates, you can use HashSet<List<Integer>> or you in the two way search skip elements which are same consecutively both ways |   | 46|
|   | 17. Letter Combinations of a Phone Number  | BackTracking with state-partial comb | Create a array of number->string | Time complexity: 4raisedtoN*N, where NN is the length of digits. Note that 44 in this expression is referring to the maximum value length in the hash map, and not to the length of the input.The worst-case is where the input consists of only 7s and 9s. In that case, we have to explore 4 additional paths for every extra digit. Then, for each combination, it costs up to NN to build the combination. This problem can be generalized to a scenario where numbers correspond with up to MM digits, in which case the time complexity would be O(Mraisef to N * N)O(M N ⋅N). For the problem constraints, we're given, M = 4M=4, because of digits 7 and 9 having 4 letters each  | 47
|   | 19. Remove Nth Node From End of List  | 2 pass easy, one pass: fast pointer N+1, slow pointer at start, pointer stops at N-1th Node | Use a dummy Node, fast, slow |   | 48|
|   | 22. Generate Parentheses  | BackTracking with state=openbracketcount, closebracketcount, length. add open if less than len and add close if less than open |O(4raisedton/sqrtn) some catlan number |   | 49|
|   | 29. Divide Two Integers  | SKIP | |   | 50|
|   | 33. Search in Rotated Sorted Array  | Two binary searches: first find pivot, second find the ans | |   | 51|
|   | 34. Find First and Last Position of Element in Sort | BINARY SEARCH with lastfound pattern | |   | 52|
|   | 36. Valid Sudoku  | Two approaches: Use List<HashSet> *3 = (row,col, boxes). For box: index=(i/3)*3+(j/3);   | Easier approach: Set<String>: Number in row I, col J, box i/3,j/3|   | 53|
|   | 38. Count and Say  | SKIP | |   | 54|
|   | 46. Permutations  | O(N!) BackTracking: Permutation is (1,2,3) =>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]   | Same as combination, except start from 0 and skip if exisits in partial list (review code)| O(N!)-O(N×N!)  | 55|
|   | 48. Rotate Image  | Transpose & Swap  |(matrix[i][j]=matrix[j][i]) & (matrix[i][j]=matrix[i][matrix.length-1-j]) |   | 56|
|   | 49. Group Anagrams  | O(N*K*LOG(K)) Sort, hashmap, O(NK)=> Encode String to alphabets a12b23... + HashMap | |   | 57|
|   | 50. Pow(x, n)  | Compute Positive Power first(binary search) then handle for x<0 and n is not even and handle for case when n<0 |  O(log(n)) |   | 58|
|   | 53. Maximum Subarray continuos | Prefix Sum/ Running Sum (Add if >0) | Maintain a max Counter|   | 59 |
|   | 54. Spiral Matrix  | Top/Bottom/Left/Right | After every update, check if left>right or top>bottom break;  |   | 60 |
|   | 55. Jump Game  | DP and Greedy(optmized) | DISCUSS WITH PRACHI- TODO |   | 61 |
|   | 56. Merge Intervals  | Custom Comparator Sort the List and then simply merge intervals | To avoid edge cases, insert one interval in the result list and compare last element and current interval at hand  |   | 62|
|   | 62. Unique Paths  | TODO: Dynamic Programming | |   | 63|
|   | 73. Set Matrix Zeroes  | Use the first row, first col and two variables for 0,0 row,column to see if it is zero | |   | 64|
|   | 75. Sort Colors  |  Dutch National Flag  | Initialize low_bounday=-1 and high boundary=lenofarray() |   | 65|
|   | 78. Subsets  | BackTracking with state as Index where to start from. Add at each backtracking step | O(N×2^N) O(N)|   | 66|
|   | 79. Word Search  | Simple DFS with state as partial word to find | | int[][] dirs={{0,1},{0,-1},{1,0},{-1,0}};  | 67|
|   | 91. Decode Ways  | TODO: DP | |  | 68|
|   | 98. Validate Binary Search Tree  | Recursion with state min and max | Use min and max as Null and handle them instead of max, min int to avoid edge cases |  | 69|
|   | 102. Binary Tree Level Order Traversal  | BFS on Tree | Create a ArrayList for levels to use index as levels |  | 70|
|   | 103. Binary Tree Zigzag Level Order Traversal  | DFS on Tree with Level as State | Trick: level%2==0 add back/front for zigzag |  | 71|
|   | 105. Construct Binary Tree from Preorder and Inorder  | TODO | |  | 72|
|   | 116. Populating Next Right Pointers in Each Node  | For every Node, root.left.next=root.right, if root.next!=null and root.right!=null root.right.next=root.next.left |Trick is: to copy next node in different subtree, access the roots next nodes left child |  | 73|
|   | 122. Best Time to Buy and Sell Stock II (Unlimited Buy/Sell) | Basically subtract consecutive elements and add it to profit. Why? You want increasing numbers basically | | | 74|
|   | 128. Longest Consecutive Sequence  | Use HashSet to store all numbers, for each num in array, try to explore all +1 and -1 from element and modify hashset. | |  | 75|
|   | 130. Surrounded Regions  | TODO | | | 76|
|   | 131. Palindrome Partitioning  | TODO:DP | |  | 77|
|   | 134. Gas Station  | Greedy, start at station, whenever negative tank , reset to current_tank=0, if total_tank==0 return starting station | | | 78|
|   | 138. Copy List with Random Pointer  | Use HashMap<OldNode,NewNode> for easy implementation O(N) space, For O(1) space weave and unweave a list. A->A'->B->B'| |  | 79|
|   | 139. Word Break  | BackTracking Brute Force, TODO:DP  | | |80|
|   | 146. LRU Cache  | Double LinkedList with Hashmap | 1. Use dummy Node. 2. Break into functions: addNode, removeNode, removeLRUNode, put, get. 3. Individual functions maintain the maps |  | 81|
|   | 148. Sort List  | SKIP | |  | 82|
|   | 150. Evaluate Reverse Polish Notation  |  | |  | 83|
|   | 152. Maximum Product Subarray  | maintain max_so_far and min_so_far, max_result, keep updating both of them with Math.max and Math.min | | | 84|
|   | 155. Min Stack  | Use Two Stacks, one stack for minimum number and get minimum in from that stack | |  | 85|
|   | 162. Find Peak Element  | Binary Search and split on if nums[mid]>nums[mid+1] r=mid | Intution is if increasing elements keep going right as cliff at the last element |  | 86|
|   | 166. Fraction to Recurring Decimal  |  SKIP | |  | 87|
|   | 172. Factorial Trailing Zeroes  |  SKIP | |  | 88|
|   | 179. Largest Number  | Convert Int -> String, Write Custom Comparator for string by String Maninpulation | |  | 89|
|   | 189. Rotate Array  | Original List  1 2 3 4 5 6 7 After reversing all numbers    7 6 5 4 3 2 1 After reversing first k numbers 5 6 7 4 3 2 1 After revering last n-k numbers 5 6 7 1 2 3 4 | | Ensure K<N | 90|
|   | 198. House Robber  | TODO: DP  | |  | 91|
|   | 200. Number of Islands  | Simple DFS and count, flip visited islands | |  | 92|
|   | 204. Count Primes   | TODO: Prachi  | | |  93|
|   | 207. Course Schedule  | Topological Sort  | countParents, add zero parents in the Q, Simple BFS Algorithm|  | 94|
|   | 208. Implement Trie (Prefix Tree)  | class TrieNode{ Map<Chracter,TrieNode>, boolean ends} | |  | 95|
|   | 210. Course Schedule II  | Standard Topological Sort | |  | 96|
|   | 215. Kth Largest Element in an Array  | Easy: PriorityQueue or Also Quick Select for space: O(1) but worst case O(N^2) | |   | 97|
|   | 227. Basic Calculator II  | Two stack Four cases: 1)Digit (keep adding) 2) '(' Keep Adding 3) ')' Compute till you encounter '(' 4) (any operator) (if(curr=* or / and stack.peek() =='+' or '-') skip else compute till you staisfy | |  | 98|
|   | 230. Kth Smallest Element in a BST  | Inorder Traversal, keep a counter, return the result | Recursive and Iterative |  | 99|
|   | 236. Lowest Common Ancestor of a Binary Tree  | Assumption that both p and q exisits. Return p or q or Node | |  | 100|
|   | 238. Product of Array Except Self  | Naive: Use additional array, left and right and get ans  | Optimized: Use result array to store product |  | 6101|
|   | 240. Search a 2D Matrix II  | Search Space Reduction, keep reducing the search space till 0 | matrix[r][c]>target : r-- else c++ |  | 102|
|   | 251. Flatten 2D Vector  | TODO: | |  | 103|
|   | 253. Meeting Rooms II  | Merge Intervals + Size of the List is the ans | |  | 104|
|   | 277. Find the Celebrity  | Logical Deduction, if anyone knows i, candidate=i. Check is candidate is the right one. | |  | 105|
|   | 279. Perfect Squares  | TODO: | |  | 106|
|   | 285. Inorder Successor in BST  | Recursive is easy, try iterative (use a stack and a boolean flag) | |  | 107|
|   | 287. Find the Duplicate Number  | TODO: PRACHI CODE Use Array as HashMap to avoid using space | Other approach is to use fast and slow pointer approach |  | 108|
|   | 289. Game of Life  |  | |  | 109|
|   | 300. Longest Increasing Subsequence  | TODO: DP | |  | 110|
|   | 322. Coin Change  | TODO: DP | |  | 111|
|   | 324. Wiggle Sort II  |  |  |  | 112|
|   | 328. Odd Even Linked List  |  |  |  | 113|
|   | 334. Increasing Triplet Subsequence  |  | |   | 114|
|   | 340. Longest Substring with At Most K Distinct Characters  | Two Pointer Approach with HashMap |  |  | 115|
|   | 341. Flatten Nested List Iterator  | Use Stack	 | populate_Stack while hasNext call and keep popping till integer in the top of stack |  | 116|
|   | 347. Top K Frequent Elements  | Priority Queue of Size K or Quick Select (worst case is O(N^2) | |  | 117|
|   | 348. Design Tic-Tac-Toe  |  | | keep rows[], cols[], diag, anti-diag, assign +1 and -1 to each player, after turn return player | 118|
|   | 371. Sum of Two Integers  | BIT operations, SKIP | |  | 120|
|   | 378. Kth Smallest Element in a Sorted Matrix  | Same as Smallest element in K Lists -> Sort sorted lists. PriorityQueue with ListNodes, rememeber?  | |  | 121|
|   | 380. Insert Delete GetRandom O(1)  | ArrayList + HashMap<Integer,Index> (If followup duplicated allowed use HashMap<Integer,Set>() | remove - replace index element with last element |  | 123|
|   | 384. Shuffle an Array  |  | | | 124|
|   | 395. Longest Substring with At Least K Repeating  | TODO: | |  | 125|
|   | 454. 4Sum II  | Iterate over two arrays at a time, and then iterate over other two to see if negate is present or not | |  | 126|
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
|   |   |  | | |  | |
	
## Hard Questions (21)
|Difficulty | Problem  | Logic | Implementation Trick| LeetCode Number| SR. | 
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| 4. Median of Two Sorted Arrays  |  The key point of this problem is to ignore half part of A and B each step recursively by comparing the median of remaining A and B:if (aMid < bMid) Keep [aRight + bLeft]    else Keep [bRight + aLeft]As the following: time=O(log(m + n)) |  | | |  | |
| 10. Regular Expression Matching  |   |  | | |  | |
| 23. Merge k Sorted Lists |  Priority Queue or Divide and Conquer | Use dummyNode, input should be ListNodes for PQ.   | | |  | |
| 41. First Missing Positive |   |  | | |  | |
| 41. First Missing Positive  |   |  | | |  | |
|  42. Trapping Rain Water |   |  | | |  | |
|  44. Wildcard Matching |   |  | | |  | |
|  76. Minimum Window Substring |   |  | | |  | |
|  84. Largest Rectangle in Histogram|   |  | | |  | |
| 124. Binary Tree Maximum Path Sum |   |  | | |  | |
| 127. Word Ladder |   |  | | |  | |
|140. Word Break II |   |  | | |  | |
|149. Max Points on a Line|   |  | | |  | |
|212. Word Search II|   |  | | |  | |
|218. The Skyline Problem|   |  | | |  | |
|239. Sliding Window Maximum|   |  | | |  | |
|269. Alien Dictionary|   |  | | |  | |
|295. Find Median from Data Stream|   |  | | |  | |
|297. Serialize and Deserialize Binary Tree|   |  | | |  | |
|329. Longest Increasing Path in a Matrix|   |  | | |  | |


1. Two Sum
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map=new HashMap<>();
        
        for(int i=0;i<nums.length;i++){
            int complement=target-nums[i];
            if(map.get(complement)!=null){
                return new int[]{map.get(complement),i};
            }
            map.put(nums[i],i);
        }
        return new int[]{};
    }
}

```
14. Longest Common Prefix
```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        StringBuilder sb=new StringBuilder();
        int index=0;
        if(strs.length==0) return "";
        while(index<strs[0].length()){
            char c=strs[0].charAt(index);
            boolean allSame=true;
            for(String curr:strs){
                if(curr.length()<=index||c!=curr.charAt(index)){
                    allSame=false;
                    break;
                }
            }
            if(allSame) sb.append(c);
            else break;
            index++;
        }
        return sb.toString();
    }
}
```
20. Valid Parentheses
```java
public class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for(int i = 0; i < s.length(); i++) {
            char a = s.charAt(i);
            if(a == '(' || a == '[' || a == '{') stack.push(a);
            else if(stack.empty()) return false;
            else if(a == ')' && stack.pop() != '(') return false;
            else if(a == ']' && stack.pop() != '[') return false;
            else if(a == '}' && stack.pop() != '{') return false;
        }
        return stack.empty();
    }
}
```

21. Merge Two Sorted Lists
```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummyNode=new ListNode(-1);
        ListNode front=dummyNode;
        while(l1!=null||l2!=null){
            ListNode nextNode=l1==null?l2:(l2==null?l1:(l1.val<l2.val?l1:l2));
            front.next=nextNode;
            if(nextNode==l1) l1=l1.next;
            else l2=l2.next;
            front=front.next;
        }
        return dummyNode.next;
    }
}
```
26. Remove Duplicates from Sorted Array
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0) return 0;
        int start=0, curr=0;
        while(curr<nums.length){
            if(nums[curr]!=nums[start]){
                nums[++start]=nums[curr];
            }
            curr++;
        }
        // handle last element
        if(nums[nums.length-1]!=nums[start]) nums[start++]=nums[nums.length-1];
        // return start+1
        return start+1;
    }
}
```

28. Implement strStr()
```java
class Solution{
    public int strStr(String haystack, String needle) {
        // empty needle appears everywhere, first appears at 0 index
        if (needle.length() == 0)
            return 0;
        if (haystack.length() == 0)
            return -1;
        
        
        for (int i = 0; i < haystack.length(); i++) {
            // no enough places for needle after i
            if (i + needle.length() > haystack.length()) break;
            
            for (int j = 0; j < needle.length(); j++) {
                if (haystack.charAt(i+j) != needle.charAt(j))
                    break;
                if (j == needle.length()-1)
                    return i;
            }
        }
        
        return -1;
    }
}
```

33. Search in Rotated Sorted Array
```java
class Solution {
    public int search(int[] nums, int target) {
        if (nums.length == 1) {
            return nums[0] == target ? 0 : -1;
        }
        
        int i = findStartIndex(nums, target);
        int n = nums.length;
        
        if (nums[i] == target) {
            return i;
        }
        
        if (i == 0) {
            return search(0, n - 1, nums, target);
        }
        
        if (target < nums[0]){
            // search in the right side
            return search(i, n - 1, nums, target);
        }
        // search in the left side
        return search(0, i, nums, target);
    }
    
    public int findStartIndex(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        if (nums[left] < nums[right]) {
            return 0;
        }
        
        while (left <= right) {
            int pivot = (left + right) / 2;
            if (nums[pivot] > nums[pivot + 1]){
                return pivot + 1;
            } else {
                if (nums[pivot] < nums[left]){
                    right = pivot - 1;
                } else {
                    left = pivot + 1;
                }
            }
        }
        return 0;
    }
    
    public int search(int left, int right, int[] nums, int target) {
        while (left <= right) {
            int pivot = (left + right) / 2;
            if (nums[pivot] == target) {
                return pivot;
            } else {
                if (target < nums[pivot]) {
                    right = pivot - 1;
                } else{
                    left = pivot + 1;
                }
            }
        }
        return -1;
    }
}
```
66. Plus One
```java
public int[] plusOne(int[] digits) {
    int carry = 1;
    for (int i = digits.length-1; i>= 0; i--) {
        digits[i] += carry;
        if (digits[i] <= 9) // early return 
            return digits;
        digits[i] = 0;
    }
    int[] ret = new int[digits.length+1];
    ret[0] = 1;
    return ret;
}
```

69. Sqrt(x)
```java
class Solution {
    public int mySqrt(int x) {
        if (0 == x) return 0;
        int left = 1, right = x, ans=1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mid <= x / mid) {
                left = mid + 1;
                ans = mid;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }
}
```

70. Climbing Stairs
```java
class Solution {
    HashMap<Integer,Integer> dp;
    public int climbStairs(int n) {
        dp=new HashMap<Integer,Integer>();
        dp.put(0,1);
        dp.put(1,1);
        for(int i = 2; i<=n;i++) {
            dp.put(i, dp.get(i-1) + dp.get(i-2));
        }
        
        return dp.get(n);
    }
}
```

88. Merge Sorted Array
```java
class Solution {
    
    /**
    arr   123000
    index 012345
    m=3
    
    arr   256
    index 012
    n=3
    
    index=m+n-1
    j=m-1;
    i=n-1;
                 
    index 012345
    
    
    **/
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index=m+n-1;
        int i=m-1;
        int j=n-1;
        while(i>=0||j>=0){
            //System.out.println(i+" "+j);
            if(i<0)nums1[index--]=nums2[j--];
            else if(j<0) nums1[index--]=nums1[i--];
            else{
                nums1[index--]=nums1[i]>nums2[j]?nums1[i--]:nums2[j--];
            }
        }
        while(i>=0){
            nums1[index--]=nums1[i--];
        }
        while(j>=0){
            nums1[index--]=nums1[j--];
        }
    }
}
```

94. Binary Tree Inorder Traversal

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans=new ArrayList<Integer>();
        traverse(root,ans);
        return ans;
    }
    public void traverse(TreeNode root, List<Integer> ans){
        if(root!=null){
            traverse(root.left,ans);
            ans.add(root.val);
            traverse(root.right,ans);
        }
        return;
    }
}
```

101. Symmetric Tree
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        return isEqual(root.left,root.right);
    }
    
    public boolean isEqual(TreeNode node1, TreeNode node2){
        if(node1==null) return node2==null;
        if(node2==null) return node1==null;
        if(node1.val!=node2.val) return false;
        return isEqual(node1.left,node2.right) && isEqual(node1.right,node2.left);
    }
}
```

104. Maximum Depth of Binary Tree
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return Integer.max(maxDepth(root.left),maxDepth(root.right))+1;
    }
}
```
108. Convert Sorted Array to Binary Search Tree
```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return toBST(0,nums.length-1,nums);
    }
    public TreeNode toBST(int start, int end, int[] nums){
        if(start>end) return null;
        int mid=(start+end)/2;
        TreeNode node=new TreeNode(nums[mid]);
        node.left=toBST(start,mid-1,nums);
        node.right=toBST(mid+1,end,nums);
        return node;
    }
}
```

118. Pascal's Triangle
```java
public class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> triangle = new ArrayList<List<Integer>>();
        if (numRows <=0){
            return triangle;
        }
        for (int i=0; i<numRows; i++){
            List<Integer> row =  new ArrayList<Integer>();
            for (int j=0; j<i+1; j++){
                if (j==0 || j==i){
                    row.add(1);
                } else {
                    row.add(triangle.get(i-1).get(j-1)+triangle.get(i-1).get(j));
                }
            }
            triangle.add(row);
        }
        return triangle;
    }
}
```

121. Best Time to Buy and Sell Stock
```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==0) return 0;
        int min_so_far=prices[0];
        int maxP=0;
        
        for(int i=0;i<prices.length;i++){
            if((prices[i]-min_so_far)>maxP) maxP=(prices[i]-min_so_far);
            min_so_far=Math.min(prices[i],min_so_far);
        }
        return maxP;
        
    }
}
```

125. Valid Palindrome
```java
class Solution {
    public boolean isPalindrome(String s) {
        int start=0,end=s.length()-1;
        String newS=s;
        while(start<end){
            while(start<end&&!Character.isLetterOrDigit(newS.charAt(start))) start++;
            while(start<end&&!Character.isLetterOrDigit(newS.charAt(end))) end--;
            Character startC=Character.toLowerCase(newS.charAt(start));
            char endC=Character.toLowerCase(newS.charAt(end));
            if(start>end) return false;
            if(startC!=endC) return false;
            start++;
            end--;
        }
        return true;
    }
}
```
136. Single Number
```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans=0;
        for(int i=0;i<nums.length;i++){
            ans=ans^nums[i];
        }
        return ans;
    }
}
```

141. Linked List Cycle
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null) return false;
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
            if(slow==fast) return true; 
        }
        return false;
    }
}
```

160. Intersection of Two Linked Lists
```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    int lenA = length(headA), lenB = length(headB);
    // move headA and headB to the same start point
    while (lenA > lenB) {
        headA = headA.next;
        lenA--;
    }
    while (lenA < lenB) {
        headB = headB.next;
        lenB--;
    }
    // find the intersection until end
    while (headA != headB) {
        headA = headA.next;
        headB = headB.next;
    }
    return headA;
}

private int length(ListNode node) {
    int length = 0;
    while (node != null) {
        node = node.next;
        length++;
    }
    return length;
}
```

169. Majority Element
```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }

        return candidate;
    }
}
```
171. Excel Sheet Column Number

```java
public class Solution {
    public int titleToNumber(String s) {
        if (s == null) return -1;
        int sum = 0;
        // for each loop so we don't need to mess with index values.
        for (char c : s.toUpperCase().toCharArray()) {
            sum *= 26;
            sum += c - 'A' + 1;
        }
        return sum;
    }
}
```

202. Happy Number
```java
class Solution {
    public boolean isHappy(int n) {
        HashSet<Integer> set=new HashSet<Integer>();
        int num=n;
        set.add(num);
        while(true){
            num=getNextNum(num);
            if(num==1) return true;
            if(set.contains(num)) return false;
            set.add(num);
        }
    }
    public Integer getNextNum(int n){
        int newNum=0;
        while(n!=0){
            newNum+=(n%10)*(n%10);
            n=n/10;
        }
        return newNum;
    }
}
```

206. Reverse Linked List
```java
public ListNode reverseList(ListNode head) {
    /* iterative solution */
    ListNode newHead = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = newHead;
        newHead = head;
        head = next;
    }
    return newHead;
}

//Take 1 -> 2 -> 3 -> N for example, we reverse the list by
//put 1's previous node null as 1's next,
//put 2's previous node 1 as 2's next,
//put 3's previous node 2 as 3's next,
//return 3 // put null's previous node 3 as null's next

    public ListNode reverseList(ListNode head) {
        return putPreAfterNode(head, null);
    }

    private ListNode putPreAfterNode(ListNode node, ListNode pre) {
        if (node == null) {
            return pre;
        }
        ListNode next = node.next;
        node.next = pre;
        return putPreAfterNode(next, node);
    }

```

217. Contains Duplicate
```java
public  boolean containsDuplicate(int[] nums) {
		 Set<Integer> set = new HashSet<Integer>();
		 for(int i : nums)
			 if(!set.add(i))// if there is same
				 return true; 
		 return false;
	 }
```

234. Palindrome Linked List
```java
/**
Picture:
    node at front, node at end, they compare and move towards each other
    
    [] - [] - [] - [] - [] - [] - NULL
    (f)->                  <-(e)  
    
    -(e) recursions foward and then back
    -(f) move to next if values equal
 */

class Solution {
    ListNode node;
    
    public boolean isPalindrome(ListNode head) {
        if(head == null) return true;   
        if(node == null) node = head;   //node points at front
        
        boolean bool = isPalindrome(head.next); //send head to end
        
        if(head.val == node.val)    //compare the front and end nodes
            node = node.next;
        else
            bool = false;
        
        return bool;
    }
}
```

237. Delete Node in a Linked List
```java
public void deleteNode(ListNode node) {
    node.val=node.next.val;
    node.next=node.next.next;
}
```

242. Valid Anagram
```java
public class Solution {
    public boolean isAnagram(String s, String t) {
        int[] alphabet = new int[26];
        for (int i = 0; i < s.length(); i++) alphabet[s.charAt(i) - 'a']++;
        for (int i = 0; i < t.length(); i++) alphabet[t.charAt(i) - 'a']--;
        for (int i : alphabet) if (i != 0) return false;
        return true;
    }
}
```

268. Missing Number
```java
public class Solution {
    public int missingNumber(int[] nums) {
        int sum = 0;
        for(int num: nums)
            sum += num;
            
        return (nums.length * (nums.length + 1) )/ 2 - sum;
    }
}
// To avoid overflow: return ( (nums.length * (nums.length + 1) ) - 2 * sum ) / 2;
```

283. Move Zeroes
```java
    public void moveZeroes(int[] nums) {
        int start=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=0){
                nums[start++]=nums[i];
            }
        }
        while(start<nums.length){
            nums[start]=0;
            start++;
        }
    }
}
```

326. Power of Three

```java
bool isPowerOfThree(int n) {
	if(!n) return false;
	while(n % 3 == 0) n /= 3;    
	return n == 1;
}
```

344. Reverse String
```java
class Solution {
    // // Write a function that reverses a string. The input string is given as an array of characters s.
    // Key: is to keep two pointers rather than 1 pointer

    public void reverseString(char[] s) {
      helper(0, s.length - 1, s);
    }

    private void helper(int start, int end, char [] s) {
      if (start >= end) {
        return;
      } 
      // swap between the first and the last elements.
      char tmp = s[start];
      s[start] = s[end];
      s[end] = tmp;
       
      helper(start + 1, end - 1, s);
   }
}
```

387. First Unique Character in a String
```java
class Solution {
    public int firstUniqChar(String s) {
        HashMap<Character, Integer> count = new HashMap<Character, Integer>();
        int n = s.length();
        // build hash map : character and how often it appears
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            count.put(c, count.getOrDefault(c, 0) + 1);
        }
        
        // find the index
        for (int i = 0; i < n; i++) {
            if (count.get(s.charAt(i)) == 1) 
                return i;
        }
        return -1;
    }
}
```

412. Fizz Buzz
```java
class Solution {
    public List<String> fizzBuzz(int n) {
        List<String> ans=new ArrayList<String>();
        if(n<1) return ans;
        for(int i=1;i<=n;i++){
            StringBuilder sb=new StringBuilder("");
            if(i%3==0&&i%5==0) sb.append("FizzBuzz");
            else if(i%3==0) sb.append("Fizz");
            else if(i%5==0) sb.append("Buzz");
            else sb.append(i);
            
            ans.add(sb.toString());
        }
        return ans;
    }
}
```

## Medium 
13. Roman to Integer
	    
//https://leetcode.com/problems/roman-to-integer/
```java
 class Solution {
    public int romanToInt(String s) {
    int nums[]=new int[s.length()];
    for(int i=0;i<s.length();i++){
        switch (s.charAt(i)){
            case 'M':
                nums[i]=1000;
                break;
            case 'D':
                nums[i]=500;
                break;
            case 'C':
                nums[i]=100;
                break;
            case 'L':
                nums[i]=50;
                break;
            case 'X' :
                nums[i]=10;
                break;
            case 'V':
                nums[i]=5;
                break;
            case 'I':
                nums[i]=1;
                break;
        }
    }
    int sum=0;
    for(int i=0;i<nums.length-1;i++){
        if(nums[i]<nums[i+1])
            sum-=nums[i];
        else
            sum+=nums[i];
    }
    return sum+nums[nums.length-1];
}
}	    
```
	    
	    
2. Add Two Numbers
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyNode=new ListNode(-1);
        ListNode front;
        front=dummyNode;
        int carry=0;
        int sum=0;
        while(l1!=null||l2!=null){
            sum=0;
            sum+=l1!=null?l1.val:0;
            sum+=l2!=null?l2.val:0;
            sum+=carry;
            
            ListNode newNode=new ListNode(sum%10);
            carry=sum/10;
            front.next=newNode;
            front=newNode;
            l1=l1!=null?l1.next:l1;
            l2=l2!=null?l2.next:l2;
        }
        if(carry!=0) front.next=new ListNode(carry);
        return dummyNode.next;
    }
}
```

3. Longest Substring Without Repeating Characters
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        
        if(s.length()==0) return s.length();
        Set<Character> nums_set=new HashSet<Character>();
        
        int i=0,j=1;
        int max_len=1;
        
        nums_set.add(s.charAt(0));
        
        for(;i<s.length();i++){
            while(j<s.length()&&!nums_set.contains(s.charAt(j))){
                max_len=Math.max(j-i+1,max_len);
                nums_set.add(s.charAt(j));
                j++;
            }
            nums_set.remove(s.charAt(i));
        }
        
        return max_len;
    }
}
```

5. Longest Palindromic Substring
```java
class Solution {
   public String longestPalindrome(String s)
    {
        //check edge case
        if (s.length() == 0)
            return "";

        //initialize dp array
        int n = s.length();
        boolean[][] dp = new boolean[n][n];

        //initialize array values to true for all substrings of length 1 and 0 (the i-1 term)
        for (int i = 0; i < n; i++)
            for (int j = Math.max(0, i - 1); j <= i; j++)
                dp[i][j] = true;

        //this will be the largest palindrome if the loop finds nothing
        String ans = "" + s.charAt(0);
        int maxD = 0;

        //loop over array using sliding window technique
        for (int d = 1; d < n; d++)
        {
            for (int i = 0; i + d < n; i++)
            {
                //Check to see if edge characters are the same and if the substring
                //between them is also a palindrome
                if (s.charAt(i) == s.charAt(i + d) && dp[i + 1][i + d - 1])
                {
                    dp[i][i + d] = true;

                    //if this 'd' is larger than maxD a new largest palindrome has been found
                    if (d > maxD)
                    {
                        maxD = d;
                        ans = s.substring(i, i + d + 1);
                    }
                }
            }
        }

        return ans;
    }
}
```
	    
Brute Force
	    
```java
public class Solution {
private int lo, maxLen;

public String longestPalindrome(String s) {
	int len = s.length();
	if (len < 2)
		return s;
	
    for (int i = 0; i < len-1; i++) {
     	extendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible
     	extendPalindrome(s, i, i+1); //assume even length.
    }
    return s.substring(lo, lo + maxLen);
}

private void extendPalindrome(String s, int j, int k) {
	while (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {
		j--;
		k++;
	}
	if (maxLen < k - j - 1) {
		lo = j + 1;
		maxLen = k - j - 1;
	}
}
}
```


7. Reverse Integer
```java
 public int reverse(int x) {
        int prevRev = 0 , rev= 0;
        while( x != 0){
            rev= rev*10 + x % 10;
            if((rev - x % 10) / 10 != prevRev){
                return 0;
            }
            prevRev = rev;
            x= x/10;
        }
        return rev;
    }
```

11. Container With Most Water
	    
```java
class Solution {
    public int maxArea(int[] height) {
        int i=0;
        int j=height.length-1;
        int maxArea=0;
        while(i<j){
            maxArea=Math.max(maxArea,(j-i)*Math.min(height[j],height[i]));
            if(height[j]<height[i]) j--;
            else i++;
        }
        return maxArea;
    }
}
```
	    
15. 3Sum
	    
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans=new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(i==0||(nums[i]!=nums[i-1]))
            twoSum(nums,i,ans);
        }
        return ans;
    }
    
    public void twoSum(int[] nums, int start,List<List<Integer>> ans){
        
        int i=start;
        int j=start+1;
        int k=nums.length-1;
        while(j<k){
            int sum=nums[i]+nums[j]+nums[k];
            if(sum==0) {
                ans.add(new ArrayList<Integer>(Arrays.asList(nums[i],nums[j],nums[k])));
            };
            if(sum>0){ 
                k--;
                // Very important dont forget
                while(j<k&&nums[k]==nums[k+1]) k--;
            }
            else{ 
                j++;
                // Very important dont forget
                while(j<k&&nums[j]==nums[j-1]) j++;
            }
        }
        return;
        
    }
}
```
	    
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < nums.length && nums[i] <= 0; ++i)
            if (i == 0 || nums[i - 1] != nums[i]) {
                twoSum(nums, i, res);
            }
        return res;
    }
    void twoSum(int[] nums, int i, List<List<Integer>> res) {
        var seen = new HashSet<Integer>();
        for (int j = i + 1; j < nums.length; ++j) {
            int complement = -nums[i] - nums[j];
            if (seen.contains(complement)) {
                res.add(Arrays.asList(nums[i], nums[j], complement));
                while (j + 1 < nums.length && nums[j] == nums[j + 1])
                    ++j;
            }
            seen.add(nums[j]);
        }
    }
}
```

17. Letter Combinations of a Phone Number

```java
class Solution {
    String[] keypad={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    List<String> ans;
    
    public List<String> letterCombinations(String digits) {
        ans=new LinkedList<String>();
        combination(digits,"");
        return ans;
    }
    
    public void combination(String digits, String comb){
        if(digits.equals("")){
            if(!comb.equals("")) ans.add(comb);
            return;
        }
        for(String letter:keypad[Integer.parseInt(digits.charAt(0)+"")].split("")){
            combination(digits.substring(1,digits.length()),comb+letter);
        }
    }
}
```
	    
19. Remove Nth Node From End of List
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummyNode=new ListNode(-1);
        if(head==null||head.next==null) return null;
        dummyNode.next=head;
        ListNode front=dummyNode;
        ListNode rear=dummyNode;
        for(int i=0;i<n+1;i++){
            front=front.next;
        }
        while(front!=null){
            front=front.next;
            rear=rear.next;
        }
        if(rear.next==null) rear.next=null;
        else{rear.next=rear.next.next;}
        return dummyNode.next;
    
    }
}	    
```

22. Generate Parentheses

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList();
        backtrack(ans, "", 0, 0, n);
        return ans;
    }

    public void backtrack(List<String> ans, String cur, int open, int close, int max){
        if (cur.length() == max * 2) {
            ans.add(cur);
            return;
        }
        if (open < max)
            backtrack(ans, cur+"(", open+1, close, max);
        if (close < open)
            backtrack(ans, cur+")", open, close+1, max);
    }
}
```

34. Find First and Last Position of Element in Sorted Array

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int l=findleftBound(nums,target);
        int r=findrightBound(nums,target);
        return new int[]{l,r};
    }
    
    public int findleftBound(int[] nums, int target){
        int ans=-1;
        int start=0,end=nums.length-1;
        while(start<=end){
            int mid=start+(end-start)/2;
            if(nums[mid]==target) {ans=mid; end=mid-1;}
            else if(target>nums[mid]) start=mid+1; // Right SubArray
            else{
                end=mid-1;
            }
        }
        return ans;
    }
    public int findrightBound(int[] nums, int target){
        int ans=-1;
        int start=0,end=nums.length-1;
        while(start<=end){
            int mid=start+(end-start)/2;
            if(nums[mid]==target) {ans=mid; start=mid+1;}
            else if(target>nums[mid]) start=mid+1; // Right SubArray
            else{
                end=mid-1;
            }
        }
        return ans;
    }
    
    
}
```
	    
36. Valid Sudoku
```java
public boolean isValidSudoku(char[][] board) {
    Set seen = new HashSet();
    for (int i=0; i<9; ++i) {
        for (int j=0; j<9; ++j) {
            char number = board[i][j];
            if (number != '.')
                if (!seen.add(number + " in row " + i) ||
                    !seen.add(number + " in column " + j) ||
                    !seen.add(number + " in block " + i/3 + "-" + j/3))
                    return false;
        }
    }
    return true;
}
```
```
class Solution {
    public boolean isValidSudoku(char[][] board) {
        ArrayList<HashSet<Integer>> rows= new ArrayList<HashSet<Integer>>();
        ArrayList<HashSet<Integer>> cols= new ArrayList<HashSet<Integer>>();
        ArrayList<HashSet<Integer>> boxes= new ArrayList<HashSet<Integer>>();
        int maxR=board.length;
        int maxC=board[0].length;

            
            
        for(int i=0;i<maxR;i++){
            rows.add(new HashSet<Integer>());
        }
        for(int i=0;i<maxC;i++){
            cols.add(new HashSet<Integer>());
            boxes.add(new HashSet<Integer>());
        }
        
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]!='.'){
                    HashSet<Integer> rowSet=rows.get(i);
                    HashSet<Integer> colSet=cols.get(j);
                    int index=(i/3)*3+(j/3);
                    HashSet<Integer> box=boxes.get(index);
                    if(box.add(board[i][j]-'0')==false){ 
                        System.out.println(board[i][j]-'0');
                        return false;
                    }
                                                        
                    if(rowSet.add(board[i][j]-'0')==false) return false;
                    if(colSet.add(board[i][j]-'0')==false) return false;
                }
            }
        }
        return true;
    }
}
```

46. Permutations
```java
public List<List<Integer>> permute(int[] nums) {
   List<List<Integer>> list = new ArrayList<>();
   // Arrays.sort(nums); // not necessary
   backtrack(list, new ArrayList<>(), nums);
   return list;
}

private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){
   if(tempList.size() == nums.length){
      list.add(new ArrayList<>(tempList));
   } else{
      for(int i = 0; i < nums.length; i++){ 
         if(tempList.contains(nums[i])) continue; // element already exists, skip
         tempList.add(nums[i]);
         backtrack(list, tempList, nums);
         tempList.remove(tempList.size() - 1);
      }
   }
} 
```

48. Rotate Image

```java
class Solution {
    public void rotate(int[][] matrix) {
        matrix=traspose(matrix);
        matrix=swapRows(matrix);
    }
    public int[][] swapRows(int[][] matrix){
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix.length/2;j++){
                int temp=matrix[i][j];
                matrix[i][j]=matrix[i][matrix.length-1-j];
                matrix[i][matrix.length-1-j]=temp;
            }
        }
        return matrix;
    }
    public int[][] traspose(int[][] matrix){
        for(int i=0;i<matrix.length;i++){
            for(int j=i;j<matrix[0].length;j++){
                int temp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=temp;
            }
        }
        return matrix;
    }
}
```

49. Group Anagrams

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if (strs.length == 0) return new ArrayList();
        Map<String, List> ans = new HashMap<String, List>();
        int[] count = new int[26];
        for (String s : strs) {
            Arrays.fill(count, 0);
            for (char c : s.toCharArray()) count[c - 'a']++;

            StringBuilder sb = new StringBuilder("");
            for (int i = 0; i < 26; i++) {
                sb.append('#');
                sb.append(count[i]);
            }
            String key = sb.toString();
            if (!ans.containsKey(key)) ans.put(key, new ArrayList());
            ans.get(key).add(s);
        }
        return new ArrayList(ans.values());
    }
}
```

```
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if (strs.length == 0) return new ArrayList();
        Map<String, List> ans = new HashMap<String, List>();
        int[] count = new int[26];
        for (String s : strs) {
            Arrays.fill(count, 0);
            for (char c : s.toCharArray()) count[c - 'a']++;

            StringBuilder sb = new StringBuilder("");
            for (int i = 0; i < 26; i++) {
                sb.append('#');
                sb.append(count[i]);
            }
            String key = sb.toString();
            if (!ans.containsKey(key)) ans.put(key, new ArrayList());
            ans.get(key).add(s);
        }
        return new ArrayList(ans.values());
    }
}
```
	    
50. Pow(x, n)
	    
```java
class Solution {
    public double myPow(double x, int n) {
        if(x==0)
            return 0;
        if(n==0)
            return 1;
        if(n==1)
            return x;
        
        double result = positivePower(Math.abs(x), Math.abs(n));
        
        // double result=positivePower;
        
        if(x<0 && n%2!=0)
            result = -1*result;
        if(n<0)
            result=1/result;
        return result;
    }
    
    
    public double positivePower(double x, int n){
        if(x==0)
            return 0;
        if(n==0)
            return 1;
        if(n==1)
            return x;
        
        double halfPow = positivePower(x, n/2);
        if(n%2!=0)
            return halfPow*halfPow*x;
        else
            return halfPow*halfPow;
    }
```

53. Maximum Subarray continuos
```java
class Solution {
  public int maxSubArray(int[] nums) {
    int max=Integer.MIN_VALUE;
    int prev=0;
    for(int i=0;i<nums.length;i++){
        int add_prev=Math.max(0,prev);
        max=Math.max(max,Math.max(nums[i], nums[i]+prev));
        prev=Math.max(nums[i], nums[i]+prev);
    }
      return max;
  }
}	    
```

54. Spiral Matrix

```java
public class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<Integer>();
        if(matrix.length == 0 || matrix[0].length == 0) return res;
        
        int top = 0;
        int bottom = matrix.length-1;
        int left = 0;
        int right = matrix[0].length-1;
        
        while(true){
            for(int i = left; i <= right; i++) res.add(matrix[top][i]);
            top++;
            if(left > right || top > bottom) break;
            
            for(int i = top; i <= bottom; i++) res.add(matrix[i][right]);
            right--;
            if(left > right || top > bottom) break;
            
            for(int i = right; i >= left; i--) res.add(matrix[bottom][i]);
            bottom--;
            if(left > right || top > bottom) break;
            
            for(int i = bottom; i >= top; i--) res.add(matrix[i][left]);
            left++;
            if(left > right || top > bottom) break;
        }
        
        return res;
    }
    
}
```

56. Merge Intervals

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, new Comparator<int[]>(){
            public int compare(int[] intervalA, int[] intervalB){
                return Integer.compare(intervalA[0],intervalB[0]);
            }
        });
        
        LinkedList<int[]> ans=new LinkedList<int[]>();
        if(intervals.length==0) return ans.toArray(new int[ans.size()][]); 
        ans.add(intervals[0]);
        
        for(int i=1;i<intervals.length;i++){
            if(ans.getLast()[1]>=intervals[i][0]){
                ans.getLast()[1]=Integer.max(intervals[i][1],ans.getLast()[1]);
            }else{
                ans.add(intervals[i]);
            }
        }
        return ans.toArray(new int[ans.size()][]);
        
    }
}
```

73. Set Matrix Zeroes
```java
class Solution {
    // Key Idea here is to use the matrix as the result arrays with O(1)
    public void setZeroes(int[][] matrix) {
        
        // Store results firstly for row0 and col0
        int row=-1;
        int col=-1;
        
        for(int i=0;i<matrix.length;i++){
            if(matrix[i][0]==0) row=0;
        }
        for(int i=0;i<matrix[0].length;i++){
            if(matrix[0][i]==0) col=0;
        }
        
        // Use row0 and col0 for storing if row or column is 0
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                if(matrix[i][j]==0){
                    matrix[0][j]=0;
                    matrix[i][0]=0;
                }
            }
        }
        
        // make the changes
        for(int i=1;i<matrix.length;i++){
            for(int j=1;j<matrix[0].length;j++){
                if((matrix[0][j]==0)||(matrix[i][0]==0)||(matrix[i][j]==0))
                matrix[i][j]=0;
            }
        }
        
        // make the changes for row and column
        if(row==0){
            for(int i=0;i<matrix.length;i++){
            matrix[i][0]=0;
            }
        }
        if(col==0){
            for(int i=0;i<matrix[0].length;i++){
            matrix[0][i]=0;
            }
        }
    
    }
}
```

75. Sort Colors

```java
class Solution {
    public void sortColors(int[] nums) {
        int low_boundary=-1;
        int high_boundary=nums.length;
        int i=0;
        while(i<high_boundary){ // If you do i<nums.length, it will disrupt high_boundary elements which are already processed
            if(nums[i]==0){
                swap(nums,i,++low_boundary);
                i++;// i++ because low_boundary ke baad wale elements haven't been processed.
            }
            else if(nums[i]==2){
                swap(nums,i,--high_boundary);
                //Idhar nai karneka i++ because high_boundary ke sath swap kiya toh current index pe swapped element aa gaya jo processed nahi hai.
            }
            else
                //if nums[i]==1, continue as it should be in the middle partition.
                i++;
        }
    }
   
    public void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
}
```

78. Subsets

```java
class Solution {
    List<List<Integer>> ans;
    public List<List<Integer>> subsets(int[] nums) {
        ans=new LinkedList<List<Integer>>();
        if(nums.length==0) return ans;
        generateSubsets(nums,new ArrayList<Integer>(),0);
        return ans;
    }
    public void generateSubsets(int[] nums, List<Integer> subset, int k){
        ans.add(new LinkedList<Integer>(subset));
        for(int i=k;i<nums.length;i++){
            subset.add(nums[i]);
            generateSubsets(nums,subset,i+1);
            subset.remove(subset.size()-1);
        }
    }
}
```

79. Word Search
```java
class Solution {
    public boolean exist(char[][] board, String word) {
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(dfs(board,i,j,word)) return true;
            }
        }
        return false;
    }
    public boolean dfs(char[][] board, int i, int j, String word){
        if(word==null||word.length()==0) return true;
        if(i>=0&&j>=0&&i<board.length&&j<board[0].length&&board[i][j]!='0'){
            char c=board[i][j];
            board[i][j]='0';
            if(c==word.charAt(0)){
                int[][] dirs={{0,1},{0,-1},{1,0},{-1,0}};
                for(int k=0;k<dirs.length;k++){
                    int x=dirs[k][0];
                    int y=dirs[k][1];
                    if(dfs(board,i+x,j+y,word.substring(1))) return true;
                }
            }
            board[i][j]=c;
        }
        return false;
    }
}
```
98. Validate Binary Search Tree

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
       
        return isValid(root,null,null);
    }
    public boolean isValid(TreeNode root, Integer min, Integer max){
       
        if(root==null)
            return true;
        
        if((min==null||root.val>min) && (max==null||root.val<max)){
           
            return isValid(root.left,min,root.val)&&isValid(root.right,root.val,max);
        }
        return false;
    }
}
```

102. Binary Tree Level Order Traversal
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<List<Integer>>();
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        if(root==null) return ans;
        
        q.add(root);
        int level=0;
        while(!q.isEmpty()){
            int lengthOfQueue=q.size();
            for(int i=0;i<lengthOfQueue;i++){
                TreeNode node=q.poll();
                if(i==0) ans.add(level,new ArrayList<Integer>());
                ans.get(level).add(node.val);
                if(node.left!=null) q.add(node.left);
                if(node.right!=null) q.add(node.right);
            }
            level++;
        }
        
        return ans;
    }
}
```

116. Populating Next Right Pointers in Each Node
```java
class Solution {
    public Node connect(Node root) {
        if(root==null) return null;
        if(root.left!=null){
            root.left.next=root.right;
        }
        if(root.next!=null&&root.right!=null){
            root.right.next=root.next.left;
        }
        
        connect(root.left);
        connect(root.right);
        return root;
        
    }
}
```

122. Best Time to Buy and Sell Stock II
```java
class Solution {
    public int maxProfit(int[] prices) {
		// We need prices for 2 days at least to find the profit.
        if (prices == null || prices.length <= 1) {
            return 0;
        }

        int totalProfit = 0;
        for (int i = 1; i < prices.length; i++) {
            // Checking if we can profit with previous day's price.
            // If yes, then we buy on previous day and sell on current day.
            // Add all such profits to get the total profit.
            if (prices[i - 1] < prices[i]) {
                totalProfit += prices[i] - prices[i - 1];
            }
        }

        return totalProfit;
    }
}
```

128. Longest Consecutive Sequence

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        HashSet<Integer> unique = new HashSet<>();
        for(int i: nums) unique.add(i);
        int max = 0;
        for(int i: nums) {
			// perform DFS at each unique value
            max = Math.max(max, dfs(i, unique));
        }
        return max;
    }
    
    public int dfs(int cur, HashSet<Integer> unique) {
		// do not recalculate values that have been traversed
        if(!unique.contains(cur)) return 0;
        int upper = cur + 1;
        int lower = cur -1;
		
		// explore values immediately greater than cur
        while(unique.contains(upper)) {
            unique.remove(upper);
            upper += 1;
        }
		
		// explore values immediately less than cur
        while(unique.contains(lower)) {
            unique.remove(lower);
            lower -= 1;
        }
        
        return upper - lower - 1;
    }
}

```

134. Gas Station

```java
class Solution {
  public int canCompleteCircuit(int[] gas, int[] cost) {
    int n = gas.length;

    int total_tank = 0;
    int curr_tank = 0;
    int starting_station = 0;
    for (int i = 0; i < n; ++i) {
      total_tank += gas[i] - cost[i];
      curr_tank += gas[i] - cost[i];
      // If one couldn't get here,
      if (curr_tank < 0) {
        // Pick up the next station as the starting one.
        starting_station = i + 1;
        // Start with an empty tank.
        curr_tank = 0;
      }
    }
    return total_tank >= 0 ? starting_station : -1;
  }
}
```

138. Copy List with Random Pointer

```java
public class Solution {
  // Visited dictionary to hold old node reference as "key" and new node reference as the "value"
  HashMap<Node, Node> visited = new HashMap<Node, Node>();

  public Node getClonedNode(Node node) {
    // If the node exists then
    if (node != null) {
      // Check if the node is in the visited dictionary
      if (this.visited.containsKey(node)) {
        // If its in the visited dictionary then return the new node reference from the dictionary
        return this.visited.get(node);
      } else {
        // Otherwise create a new node, add to the dictionary and return it
        this.visited.put(node, new Node(node.val, null, null));
        return this.visited.get(node);
      }
    }
    return null;
  }

  public Node copyRandomList(Node head) {

    if (head == null) {
      return null;
    }

    Node oldNode = head;

    // Creating the new head node.
    Node newNode = new Node(oldNode.val);
    this.visited.put(oldNode, newNode);

    // Iterate on the linked list until all nodes are cloned.
    while (oldNode != null) {
      // Get the clones of the nodes referenced by random and next pointers.
      newNode.random = this.getClonedNode(oldNode.random);
      newNode.next = this.getClonedNode(oldNode.next);

      // Move one step ahead in the linked list.
      oldNode = oldNode.next;
      newNode = newNode.next;
    }
    return this.visited.get(head);
  }
}
```
```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node next;
    public Node random;

    public Node() {}

    public Node(int _val,Node _next,Node _random) {
        val = _val;
        next = _next;
        random = _random;
    }
};
*/
public class Solution {
  public Node copyRandomList(Node head) {

    if (head == null) {
      return null;
    }

    // Creating a new weaved list of original and copied nodes.
    Node ptr = head;
    while (ptr != null) {

      // Cloned node
      Node newNode = new Node(ptr.val);

      // Inserting the cloned node just next to the original node.
      // If A->B->C is the original linked list,
      // Linked list after weaving cloned nodes would be A->A'->B->B'->C->C'
      newNode.next = ptr.next;
      ptr.next = newNode;
      ptr = newNode.next;
    }

    ptr = head;

    // Now link the random pointers of the new nodes created.
    // Iterate the newly created list and use the original nodes' random pointers,
    // to assign references to random pointers for cloned nodes.
    while (ptr != null) {
      ptr.next.random = (ptr.random != null) ? ptr.random.next : null;
      ptr = ptr.next.next;
    }

    // Unweave the linked list to get back the original linked list and the cloned list.
    // i.e. A->A'->B->B'->C->C' would be broken to A->B->C and A'->B'->C'
    Node ptr_old_list = head; // A->B->C
    Node ptr_new_list = head.next; // A'->B'->C'
    Node head_old = head.next;
    while (ptr_old_list != null) {
      ptr_old_list.next = ptr_old_list.next.next;
      ptr_new_list.next = (ptr_new_list.next != null) ? ptr_new_list.next.next : null;
      ptr_old_list = ptr_old_list.next;
      ptr_new_list = ptr_new_list.next;
    }
    return head_old;
  }
}
```

146. LRU Cache

```java
class LRUCache {

    DLinkNode head,tail;
    Map<Integer,DLinkNode> map;
    int capacity;
    int max_capacity;
    class DLinkNode{
        int key;
        DLinkNode prev;
        DLinkNode next;
        int val;
        public DLinkNode(int val, int key){
            this.val=val;
            this.key=key;
        }
    }
    public LRUCache(int capacity) {
        map=new HashMap<Integer,DLinkNode>();
        head=new DLinkNode(-1,-1);
        tail=new DLinkNode(-1,-1);
        head.next=tail;
        tail.prev=head;
        max_capacity=capacity;
        capacity=0;
    }
    
    public int get(int key) {
        // Get gets the recent value and moves the node to headnode
        if(capacity==0) return -1;
        if(map.get(key)==null) return -1;
        DLinkNode node=map.get(key);
        removeNode(key);
        addNode(key,node.val);
        return node.val;
    }

    
    public void addNode(int key, int value){
        DLinkNode node=new DLinkNode(value,key);
        DLinkNode temp=head.next;
        node.prev=head;
        node.next=head.next;
        head.next=node;
        temp.prev=node;
        map.put(key,node);
    }
    public void removeNode(int key){
        DLinkNode node=map.get(key);
        DLinkNode prev=node.prev;
        DLinkNode next=node.next;
        prev.next=next;
        next.prev=prev;
        map.remove(key);
    }
    public void removeLRUNode(){
        DLinkNode node=tail.prev;
        removeNode(node.key);
    }
    public void put(int key, int value) {
        if(map.get(key)==null){
            addNode(key,value);
            capacity++;
        }else{
            removeNode(key);
            addNode(key,value);
        }
        if(capacity>max_capacity) {
            removeLRUNode(); 
            capacity--;
        }
    }
}

 ```

152. Maximum Product Subarray
```java
class Solution {
    public int maxProduct(int[] nums) {
        int result=nums[0];
        int max_so_far=nums[0];
        int min_so_far=nums[0];
        for(int i=1;i<nums.length;i++){
            int curr = nums[i];
            int temp_max = Math.max(curr, Math.max(max_so_far * curr, min_so_far * curr));
            min_so_far = Math.min(curr, Math.min(max_so_far * curr, min_so_far * curr));

            max_so_far = temp_max;

            result = Math.max(max_so_far, result);
        }
        return result;
    }
}

/**

2 3 -2 -4

max = -2
min = 6
result =6 

**/
```

153. Min Stack
```java
class MinStack {

    Stack<Integer> stack;
    Stack<Integer> minStack;
    int min;
    /** initialize your data structure here. */
    public MinStack() {
        stack=new Stack<Integer>();
        minStack=new Stack<Integer>();
    }
    
    public void push(int val) {
        if(stack.isEmpty()){
            min=val;
        }else{
            min=minStack.peek();
        }
        stack.push(val);
        minStack.push(Integer.min(val,min));

    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

162. Find Peak Element

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (nums[mid] > nums[mid + 1])
                r = mid;
            else
                l = mid + 1;
        }
        return l;
    }
}
```

179. Largest Number
```java
public class Solution {
     public String largestNumber(int[] num) {
		if(num == null || num.length == 0)
		    return "";
		
		// Convert int array to String array, so we can sort later on
		String[] s_num = new String[num.length];
		for(int i = 0; i < num.length; i++)
		    s_num[i] = String.valueOf(num[i]);
			
		// Comparator to decide which string should come first in concatenation
		Comparator<String> comp = new Comparator<String>(){
		    @Override
		    public int compare(String str1, String str2){
		        String s1 = str1 + str2;
				String s2 = str2 + str1;
				return s2.compareTo(s1); // reverse order here, so we can do append() later
		    }
	     };
		
		Arrays.sort(s_num, comp);
		// An extreme edge case by lc, say you have only a bunch of 0 in your int array
		if(s_num[0].charAt(0) == '0')
			return "0";
            
		StringBuilder sb = new StringBuilder();
		for(String s: s_num)
	        sb.append(s);
		
		return sb.toString();
		
	}
}
```

189. Rotate Array

```java
class Solution {
  public void rotate(int[] nums, int k) {
    k %= nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
  }
  public void reverse(int[] nums, int start, int end) {
    while (start < end) {
      int temp = nums[start];
      nums[start] = nums[end];
      nums[end] = temp;
      start++;
      end--;
    }
  }
}
```

200. Number of Islands
```java
class Solution {
    public int numIslands(char[][] grid) {
        int num_island=0;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]=='1'){
                    floodfill(grid,i,j);
                    num_island++;
                }
            }
           
        }
        return num_island;
    }
    
    public void floodfill(char[][] grid, int i, int j){
        if(i>=0&&j>=0&&i<grid.length&&j<grid[0].length&&grid[i][j]=='1'){
            grid[i][j]='0';
            floodfill(grid,i+1,j);
            floodfill(grid,i,j+1);
            floodfill(grid,i-1,j);
            floodfill(grid,i,j-1);
        }
    }
}
```

	    
207. Course Schedule
```java
public static <T> Map<T, Integer> countParents(Map<T, List<T>> graph) {
    Map<T, Integer> counts = new HashMap<>();
    graph.keySet().forEach(node -> {
        counts.put(node, 0);
    });
    graph.entrySet().forEach(entry -> {
        for (T node : entry.getValue()) {
            counts.put(node, counts.get(node) + 1);
        }
    });
    return counts;
}

public static <T> List<T> topoSort(Map<T, List<T>> graph) {
    List<T> res = new ArrayList<>();
    Queue<T> q = new ArrayDeque<>();
    Map<T, Integer> counts = countParents(graph);
    counts.entrySet().forEach(entry -> {
        if (entry.getValue() == 0) {
            q.add(entry.getKey());
        }
    });
    while (!q.isEmpty()) {
        T node = q.poll();
        res.add(node);
        for (T child : graph.get(node)) {
            counts.put(child, counts.get(child) - 1);
            if (counts.get(child) == 0) {
                q.add(child);
            }
        }
    }
    return res;
}
```
	    
```java
public boolean canFinish(int numCourses, int[][] prerequisites) {
    int[][] matrix = new int[numCourses][numCourses]; // i -> j
    int[] indegree = new int[numCourses];
    
    for (int i=0; i<prerequisites.length; i++) {
        int ready = prerequisites[i][0];
        int pre = prerequisites[i][1];
        if (matrix[pre][ready] == 0)
            indegree[ready]++; //duplicate case
        matrix[pre][ready] = 1;
    }
    
    int count = 0;
    Queue<Integer> queue = new LinkedList();
    for (int i=0; i<indegree.length; i++) {
        if (indegree[i] == 0) queue.offer(i);
    }
    while (!queue.isEmpty()) {
        int course = queue.poll();
        count++;
        for (int i=0; i<numCourses; i++) {
            if (matrix[course][i] != 0) {
                if (--indegree[i] == 0)
                    queue.offer(i);
            }
        }
    }
    return count == numCourses;
}
```


208. Implement Trie (Prefix Tree)

```java
class TrieNode {
    Map<Character, TrieNode> nodes;
    boolean ends;
    
    TrieNode(){
        this.nodes = new HashMap<>();
    }
}

class Trie {
    
    private TrieNode trieNode;

    public Trie() {
        this.trieNode = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode head = trieNode;
        
        for(int i = 0; i < word.length(); i++){
            char ch = word.charAt(i);
            
            if(head.nodes.get(ch) != null){
                head = head.nodes.get(ch);
            }  else {
                head.nodes.put(ch, new TrieNode());
                head = head.nodes.get(ch);
            }
        }
        head.ends = true;
    }
    
    public boolean search(String word) {
        TrieNode head = trieNode;
        
        for(int i = 0; i < word.length(); i++){
            char ch = word.charAt(i);
            
            if(head.nodes.get(ch) != null){
                head = head.nodes.get(ch);
            } else {
                return false;
            }
        }
        
        return head.ends;
    }
    
    public boolean startsWith(String word) {
        TrieNode head = trieNode;
        
        for(int i = 0; i < word.length(); i++){
            char ch = word.charAt(i);
            
            if(head.nodes.get(ch) != null){
                head = head.nodes.get(ch);
            } else {
                return false;
            }
        }
        
        return true;
    }
}
```

210. Course Schedule II 
```java
public static <T> Map<T, Integer> countParents(Map<T, List<T>> graph) {
    Map<T, Integer> counts = new HashMap<>();
    graph.keySet().forEach(node -> {
        counts.put(node, 0);
    });
    graph.entrySet().forEach(entry -> {
        for (T node : entry.getValue()) {
            counts.put(node, counts.get(node) + 1);
        }
    });
    return counts;
}

public static <T> List<T> topoSort(Map<T, List<T>> graph) {
    List<T> res = new ArrayList<>();
    Queue<T> q = new ArrayDeque<>();
    Map<T, Integer> counts = countParents(graph);
    counts.entrySet().forEach(entry -> {
        if (entry.getValue() == 0) {
            q.add(entry.getKey());
        }
    });
    while (!q.isEmpty()) {
        T node = q.poll();
        res.add(node);
        for (T child : graph.get(node)) {
            counts.put(child, counts.get(child) - 1);
            if (counts.get(child) == 0) {
                q.add(child);
            }
        }
    }
    return res;
}
```

215. Kth Largest Element in an Array

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->Integer.compare(a,b));
        for(int i=0;i<nums.length;i++){
            pq.add(nums[i]);
            if(pq.size()>k) pq.poll(); 
        }
        if(pq.isEmpty()) return 0;
        return pq.peek();
    }
}
```

227. Basic Calculator II

```java
 public static int calculate(String s) {
        if (s == null || s.length() == 0) return 0;
        Stack<Integer> nums = new Stack<>(); // the stack that stores numbers
        Stack<Character> ops = new Stack<>(); // the stack that stores operators (including parentheses)
        int num = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == ' ') continue;
            if (Character.isDigit(c)) {
                num = c - '0';
                // iteratively calculate each number
                while (i < s.length() - 1 && Character.isDigit(s.charAt(i+1))) {
                    num = num * 10 + (s.charAt(i+1) - '0');
                    i++;
                }
                nums.push(num);
                num = 0; // reset the number to 0 before next calculation
            } else if (c == '(') {
                ops.push(c);
            } else if (c == ')') {
                // do the math when we encounter a ')' until '('
                while (ops.peek() != '(') nums.push(operation(ops.pop(), nums.pop(), nums.pop()));
                ops.pop(); // get rid of '(' in the ops stack
            } else if (c == '+' || c == '-' || c == '*' || c == '/') {
                // keep pushing to stack till higher or same precendece element of (* or /) is not encountered 
                while (!ops.isEmpty() && precedence(c, ops.peek())) nums.push(operation(ops.pop(), nums.pop(),nums.pop()));
                ops.push(c);
            }
        }
        while (!ops.isEmpty()) {
            nums.push(operation(ops.pop(), nums.pop(), nums.pop()));
        }
        return nums.pop();
    }

    private static int operation(char op, int b, int a) {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b; // assume b is not 0
        }
        return 0;
    }
    // helper function to check precedence of current operator and the uppermost operator in the ops stack 
    // Jab dikhe khatra ya de koi takkar, nikalo sabko stack ke andar
    private static boolean precedence(char op1, char op2) {
        if (op2 == '(' || op2 == ')') return false;
        if ((op1 == '*' || op1 == '/') && (op2 == '+' || op2 == '-')) return false;
        return true;
    }
```

230. Kth Smallest Element in a BST
// Recursive
```java
class Solution {
    	int count = 0;
	int result = Integer.MIN_VALUE;

	public int kthSmallest(TreeNode root, int k) {
	    traverse(root, k);
	    return result;
	}

	public void traverse(TreeNode root, int k) {
	    if(root == null) return;
	    traverse(root.left, k);
	    count ++;
	    if(count == k) result = root.val;
	    traverse(root.right, k);       
	}
}
```

// Iterative
```java
public int kthSmallest(TreeNode root, int k) {
     Stack<TreeNode> stack = new Stack<TreeNode>();
     TreeNode p = root;
     int count = 0;
     
     while(!stack.isEmpty() || p != null) {
         if(p != null) {
             stack.push(p);  // Just like recursion
             p = p.left;   
             
         } else {
            TreeNode node = stack.pop();
            if(++count == k) return node.val; 
            p = node.right;
         }
     }
     
     return Integer.MIN_VALUE;
 }
```

236. Lowest Common Ancestor of a Binary Tree
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
         if(root==null) return null;
         if(root==p||root==q) return root;
         TreeNode root_left=lowestCommonAncestor(root.left,p,q);
         TreeNode root_right=lowestCommonAncestor(root.right,p,q);
            
         TreeNode node_return=root_left!=null?(root_right!=null?root:root_left):root_right;
         return node_return;
    }
}
```

238. Product of Array Except Self

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] ans=new int[nums.length];
        int productSoFar=1;
        for(int i=nums.length-1;i>=0;i--){
            ans[i]=productSoFar*nums[i];
            productSoFar*=nums[i];
        }
        int product=1;
        productSoFar=1;
        for(int i=0;i<nums.length;i++){
            if(i!=nums.length-1)
            ans[i]=productSoFar*ans[i+1];
            if(i==nums.length-1)
                ans[i]=productSoFar;
            productSoFar*=nums[i];
        }
        return ans;
    }
}
```

253. Meeting Rooms II

```java
public int minMeetingRooms(Interval[] intervals) {
    if (intervals == null || intervals.length == 0)
        return 0;
        
    // Sort the intervals by start time
    Arrays.sort(intervals, new Comparator<Interval>() {
        public int compare(Interval a, Interval b) { return a.start - b.start; }
    });
    
    // Use a min heap to track the minimum end time of merged intervals
    PriorityQueue<Interval> heap = new PriorityQueue<Interval>(intervals.length, new Comparator<Interval>() {
        public int compare(Interval a, Interval b) { return a.end - b.end; }
    });
    
    // start with the first meeting, put it to a meeting room
    heap.offer(intervals[0]);
    
    for (int i = 1; i < intervals.length; i++) {
        // get the meeting room that finishes earliest
        Interval interval = heap.poll();
        
        if (intervals[i].start >= interval.end) {
            // if the current meeting starts right after 
            // there's no need for a new room, merge the interval
            interval.end = intervals[i].end;
        } else {
            // otherwise, this meeting needs a new room
            heap.offer(intervals[i]);
        }
        
        // don't forget to put the meeting room back
        heap.offer(interval);
    }
    
    return heap.size();
}
```

277. Find the Celebrity

```java
public class Solution extends Relation {
    public int findCelebrity(int n) {
        int cand=0;
        for(int i=0;i<n;i++){
            if(i!=cand&&knows(cand,i)){
                cand=i;
            }
        }
        for(int i=0;i<n;i++){
            boolean candidateKnowsAnyone=knows(cand,i);
            boolean everyOneKnowsCandidate=knows(i,cand);
            if(i!=cand&&(candidateKnowsAnyone||!everyOneKnowsCandidate)) return -1;
        }
        return cand;
    }
}
```

285. Inorder Successor in BST
```java
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        Stack<TreeNode> s=new Stack();
        TreeNode x=root;
        boolean found=false;
        while(x!=null||!s.isEmpty()){
            while(x!=null){
                s.push(x);
                x=x.left;
            }
            x=s.pop();
            if(found==true){
                return x;
            }
            found=x==p?true:false;
            x=x.right;
        }
        return null;
    }
}
```

348. Design Tic-Tac-Toe

```java
public class TicTacToe {
    private int[] rows;
    private int[] cols;
    private int diagonal;
    private int antiDiagonal;

    /** Initialize your data structure here. */
    public TicTacToe(int n) {
        rows = new int[n];
        cols = new int[n];
    }

    /** Player {player} makes a move at ({row}, {col}).
     @param row The row of the board.
     @param col The column of the board.
     @param player The player, can be either 1 or 2.
     @return The current winning condition, can be either:
     0: No one wins.
     1: Player 1 wins.
     2: Player 2 wins. */
    public int move(int row, int col, int player) {
        int toAdd = player == 1 ? 1 : -1;

        rows[row] += toAdd;
        cols[col] += toAdd;
        if (row == col)
        {
            diagonal += toAdd;
        }

        if (col == (cols.length - row - 1))
        {
            antiDiagonal += toAdd;
        }

        int size = rows.length;
        if (Math.abs(rows[row]) == size ||
                Math.abs(cols[col]) == size ||
                Math.abs(diagonal) == size  ||
                Math.abs(antiDiagonal) == size)
        {
            return player;
        }

        return 0;
    }
}
```

347. Top K Frequent Elements

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        PriorityQueue<Node> pq=new PriorityQueue(k, new Comparator<Node>(){
            public int compare(Node a, Node b){
               if(a.freq<b.freq) return -1;
                else if (a.freq>b.freq) return 1;
                else return 0;
            }
        });
        
        for(int i=0;i<nums.length;i++){
            if(map.get(nums[i])==null) map.put(nums[i],1);
            else map.put(nums[i],1+map.get(nums[i]));
        }
        for(Integer key: map.keySet()){
            Node nodeA=new Node(key);
            nodeA.freq=map.get(key);
            pq.add(nodeA);
            if(pq.size()>k) pq.poll();
        }
        int[] ans=new int[k];
        int i=0;
        while(!pq.isEmpty()){
            ans[i++]=pq.poll().val;
        }
        return ans;
    }
    
    class Node{
        public int val;
        public int freq;
        public Node(int val){
            this.val=val;
        }
    }
}
```


378. Kth Smallest Element in a Sorted Matrix
```
Approach 2 (Using Priority Queue) //By reading that we have to return kth of something,this approach usually comes into mind
Time Complexity: N * log(K) //N== n^2
Auxiliary Space Complexity: O(K)

class Solution {
    public int kthSmallest(int[][] matrix, int k) {
       PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        
        int n = matrix.length;
        
        for(int i = 0;i<n;i++){
            for(int j = 0;j<n;j++){
                if(pq.size() < k){
                    pq.add(matrix[i][j]);
                }else{ //equal to k
                    if(matrix[i][j] < pq.peek()){ //if incoming element is less than peek
                        pq.poll();
                        pq.add(matrix[i][j]);
                    }
                }
            }
        }
        
        return pq.peek();
    }
}
```


380. Insert Delete GetRandom O(1)

```java
class RandomizedSet {

    List<Integer> nums;
    Map<Integer, Integer> idxMap;
    Random random;

    public RandomizedSet() {
        nums = new ArrayList<>();
        idxMap = new HashMap<>();
        random = new Random();
    }

    public boolean insert(int val) {
        if (idxMap.containsKey(val)) {
            return false;
        }

        idxMap.put(val, nums.size());
        nums.add(val);
        return true;
    }

    public boolean remove(int val) {
        if (!idxMap.containsKey(val)) {
            return false;
        }

        int idx = idxMap.get(val);
        int lastIdx = nums.size() - 1;
        if (idx != lastIdx) {
            int lastVal = nums.get(lastIdx);
            nums.set(idx, lastVal);
            idxMap.put(lastVal, idx);
        }
        nums.remove(lastIdx);
        idxMap.remove(val);
        return true;
    }

    public int getRandom() {
        return nums.get(random.nextInt(nums.size()));
    }
}
```

454. 4Sum II
```java
 public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
		int count = 0;
		Map<Integer,Integer> hashMap = new HashMap<>();
		for (int numA : A) {
			for (int numB : B) {
				int sumAB = numA + numB;
				hashMap.put(sumAB, hashMap.getOrDefault(sumAB, 0) + 1);
			}
		}
		for (int numC : C){
			for (int numD : D){
				int sumCD = numC + numD;
				count += hashMap.getOrDefault(-sumCD,0);
			}
		}
		return count;
}
```

341. Flatten Nested List Iterator

```java
public class NestedIterator implements Iterator<Integer> {

    LinkedList<NestedInteger> stack;
    
    public NestedIterator(List<NestedInteger> nestedList) {
        stack=new LinkedList<NestedInteger>();
        populateStack(nestedList);
        
    }

    
    @Override
    public Integer next() {
        return stack.pop().getInteger();
        
    }
    
    public void populateStack(List<NestedInteger> nestedList){
        for(int i=nestedList.size()-1;i>=0;i--){
            NestedInteger ns=nestedList.get(i);
            stack.push(ns);  
        }
    }
    @Override
    public boolean hasNext() {
        
        while(!stack.isEmpty()&&!stack.peek().isInteger()){
            populateStack(stack.pop().getList());
        }
        
        return !stack.isEmpty();
    }
```


340. Longest Substring with At Most K Distinct Characters

```java
class Solution {
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        int i=0,j=0;
        HashMap<Character,Integer> map=new HashMap<Character,Integer>();
        if(s.length()==0||k==0) return 0;
        int max_window=1;
        while(i<s.length()){
            while(j<s.length()&&map.size()<=k){
                map.putIfAbsent(s.charAt(j),0);
                map.put(s.charAt(j),map.get(s.charAt(j))+1);
                if(map.size()<=k)max_window=Integer.max(max_window,j-i+1);
                j++;
            }
            Character charAtI=s.charAt(i);
            int countOfI=map.get(charAtI);
            if(countOfI>1) map.put(charAtI,countOfI-1);
            else if(countOfI==1) map.remove(charAtI);
            i++;
        }
        return max_window;
    }
}
```

103. Binary Tree Zigzag Level Order Traversal
```java

class Solution {
  protected void DFS(TreeNode node, int level, List<List<Integer>> results) {
    if (level >= results.size()) {
      LinkedList<Integer> newLevel = new LinkedList<Integer>();
      newLevel.add(node.val);
      results.add(newLevel);
    } else {
      if (level % 2 == 0)
        results.get(level).add(node.val);
      else
        results.get(level).add(0, node.val);
    }

    if (node.left != null) DFS(node.left, level + 1, results);
    if (node.right != null) DFS(node.right, level + 1, results);
  }

  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    if (root == null) {
      return new ArrayList<List<Integer>>();
    }
    List<List<Integer>> results = new ArrayList<List<Integer>>();
    DFS(root, 0, results);
    return results;
  }
}
```

Search in a 2D Matrix
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
    
        int r=matrix.length-1;
        int c=0;
        while(r>=0&&c<matrix[0].length){
            if(matrix[r][c]==target){
                return true;
            }
            if(matrix[r][c]>target){
                r--;
            }else{
                c++;
            }
        }
        return false;
        
    }
}
```

	
# Hard Questions

4. Median of Two Sorted Arrays

```java
The key point of this problem is to ignore half part of A and B each step recursively by comparing the median of remaining A and B:

if (aMid < bMid) Keep [aRight + bLeft]    
else Keep [bRight + aLeft]
As the following: time=O(log(m + n))

public double findMedianSortedArrays(int[] A, int[] B) {
	    int m = A.length, n = B.length;
	    int l = (m + n + 1) / 2;
	    int r = (m + n + 2) / 2;
	    return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0;
	}

public double getkth(int[] A, int aStart, int[] B, int bStart, int k) {
	if (aStart > A.length - 1) return B[bStart + k - 1];            
	if (bStart > B.length - 1) return A[aStart + k - 1];                
	if (k == 1) return Math.min(A[aStart], B[bStart]);
	
	int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE;
	if (aStart + k/2 - 1 < A.length) aMid = A[aStart + k/2 - 1]; 
	if (bStart + k/2 - 1 < B.length) bMid = B[bStart + k/2 - 1];        
	
	if (aMid < bMid) 
	    return getkth(A, aStart + k/2, B, bStart,       k - k/2);// Check: aRight + bLeft 
	else 
	    return getkth(A, aStart,       B, bStart + k/2, k - k/2);// Check: bRight + aLeft
}
```

10. Regular Expression Matching

```java
This Solution use 2D DP. beat 90% solutions, very simple.

Here are some conditions to figure out, then the logic can be very straightforward.

1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];
2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];
3, If p.charAt(j) == '*': 
   here are two sub conditions:
               1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty
               2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':
                              dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a 
                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a
                           or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty

```
```java
public boolean isMatch(String s, String p) {

    if (s == null || p == null) {
        return false;
    }
    boolean[][] dp = new boolean[s.length()+1][p.length()+1];
    dp[0][0] = true;
    for (int i = 0; i < p.length(); i++) {
        if (p.charAt(i) == '*' && dp[0][i-1]) {
            dp[0][i+1] = true;
        }
    }
    for (int i = 0 ; i < s.length(); i++) {
        for (int j = 0; j < p.length(); j++) {
            if (p.charAt(j) == '.') {
                dp[i+1][j+1] = dp[i][j];
            }
            if (p.charAt(j) == s.charAt(i)) {
                dp[i+1][j+1] = dp[i][j];
            }
            if (p.charAt(j) == '*') {
                if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {
                    dp[i+1][j+1] = dp[i+1][j-1];
                } else {
                    dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);
                }
            }
        }
    }
    return dp[s.length()][p.length()];
}
```

23. Merge k Sorted Lists

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq=new PriorityQueue<ListNode>(new Comparator<ListNode>(){
            public int compare(ListNode a, ListNode b){
                return a.val-b.val;
            }
        });
        
        for(int i=0;i<lists.length;i++){
            if(lists[i]!=null)
            pq.add(lists[i]);
        }
        
        ListNode dummyNode=new ListNode(-1);
        ListNode front=dummyNode;
        while(!pq.isEmpty()){
            ListNode n=pq.poll();
            if(n!=null&&n.next!=null){
                pq.offer(n.next);
                n.next=null;
            }
            front.next=n;
            front=front.next;
        }
        return dummyNode.next;
    }
}
```

41. First Missing Positive

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        if(nums==null || nums.length==0)
            return 1;
        int n=nums.length;
        boolean containsOne=false;// this is needed to keep track because agar array [2,3,-5] hua toh -5 change hoke 1 hojayega and we'll mess up the solution. So containsOne helps keep track of if original array had 1. Kyuki agar original array me 1 hai hi nahi toh that's our answer.
        
        //Step 1: All numbers <=0 and >n are set to 1.
        for(int i=0;i<n;i++){
            if(nums[i]==1)
                containsOne=true;
            else if(nums[i]<=0 || nums[i]>n)
                nums[i]=1;
        }
     // First check if containsOne is false. If false, answer is 1;   
        if(!containsOne)
            return 1;
        
        //Step 2: Take numbers and convert swap sign of corresponding index numbers.
        for(int i=0;i<n;i++){
            int index =Math.abs(nums[i]) -1;
            if(nums[index]>0)
                nums[index]*=-1;
        }
        
//         Step 3: Find first index with positive element and that index plus 1 will be our answer. 

        for(int i=0;i<n;i++){
            if(nums[i]>0)
                return i+1;
        }
        return n+1;
    }
}
```
43. Trapping Rain Water

```java
class Solution {
    public int trap(int[] height) {
  int n = height.length;
  if (n <= 2) return 0;
  // pre-compute
  int[] leftMax = new int[n];
  int[] rightMax = new int[n];
  leftMax[0] = height[0]; // init
  rightMax[n - 1] = height[n - 1];
  for (int i = 1, j = n - 2; i < n; ++i, --j) {
    leftMax[i] = Math.max(leftMax[i - 1], height[i]);
    rightMax[j] = Math.max(rightMax[j + 1], height[j]);
  }
  // water
  int totalWater = 0;
  for (int k = 1; k < n - 1; ++k) { // do not consider the first and the last places
    int water = Math.min(leftMax[k - 1], rightMax[k + 1]) - height[k];
    totalWater += (water > 0) ? water : 0;
  }
  return totalWater;
}
}

/**
Refer to LC solution 4.

**/
```
45. Wildcard Matching

```
The original post has DP 2d array index from high to low, which is not quite intuitive.

Below is another 2D dp solution. Ideal is identical.

dp[i][j] denotes whether s[0....i-1] matches p[0.....j-1],

First, we need to initialize dp[i][0], i= [1,m]. All the dp[i][0] should be false because p has nothing in it.

Then, initialize dp[0][j], j = [1, n]. In this case, s has nothing, to get dp[0][j] = true, p must be '*', '**', '***',etc. Once p.charAt(j-1) != '*', all the dp[0][j] afterwards will be false.

Then start the typical DP loop.

Though this solution is clear and easy to understand. It is not good enough in the interview. it takes O(mn) time and O(mn) space.

Improvement: 1) optimize 2d dp to 1d dp, this will save space, reduce space complexity to O(N). 2) use iterative 2-pointer
```
```java
public boolean isMatch_2d_method(String s, String p) {
	int m=s.length(), n=p.length();
	boolean[][] dp = new boolean[m+1][n+1];
	dp[0][0] = true;
	for (int i=1; i<=m; i++) {
		dp[i][0] = false;
	}
	
	for(int j=1; j<=n; j++) {
		if(p.charAt(j-1)=='*'){
			dp[0][j] = true;
		} else {
			break;
		}
	}
	
	for(int i=1; i<=m; i++) {
		for(int j=1; j<=n; j++) {
			if (p.charAt(j-1)!='*') {
				dp[i][j] = dp[i-1][j-1] && (s.charAt(i-1)==p.charAt(j-1) || p.charAt(j-1)=='?');
			} else {
				dp[i][j] = dp[i-1][j] || dp[i][j-1];
			}
		}
	}
	return dp[m][n];
}
```


76. Minimum Window Substring

```java
class Solution {
    public String minWindow(String s, String t) {
        // corner case
        if(s == null || t == null || s.length() == 0 || t.length() == 0 || s.length() < t.length()) return "";
        
        // construct model
        int minLeft = 0;
        int minRight = 0;
        int min = s.length();
        boolean flag = false;
        
        Map<Character, Integer> map = new HashMap<>();
        int count = t.length(); // the number of characters that I need to match
        for(char c : t.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1);
        
        // unfixed sliding window, 2 pointers
        int i = 0;
        int j = 0;
        while(j < s.length()){
            char c = s.charAt(j);
            if(map.containsKey(c)){
                map.put(c, map.get(c) - 1);
                if(map.get(c) >= 0) count--; // if still unmatched characters, then count--
            }
            
            // if found a susbtring
            while(count == 0 && i <= j){
                // update global min
                flag = true;
                int curLen = j + 1 - i;
                if(curLen <= min){
                    minLeft = i;
                    minRight = j;
                    min = curLen;
                }
                
                // shrink left pointer
                char leftC = s.charAt(i);
                if(map.containsKey(leftC)){
                    map.put(leftC, map.get(leftC) + 1);
                    if(map.get(leftC) >= 1) count++;
                }
                i++;
            } 
            j++;
        }
        
        return flag == true ? s.substring(minLeft, minRight + 1): "";
    }
}
```

84. Largest Rectangle in Histogram
```java
```


124. Binary Tree Maximum Path Sum

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        if(root==null)
            return 0;
        
        pathSum(root);
        return max;
    }
    
    public int pathSum(TreeNode root){
        if(root==null)
            return 0;
        
        int lSum = pathSum(root.left);
        int rSum = pathSum(root.right);
        
        //         At any node in the tree, there can be four possibilities:
//         1. Max at the current node is just itself
//         2. Max is leftChild + current
//         3. Max is rightChild + current
//         4. Max is leftChild + rightChild + current.
        
        int rootWithMaxChildSum = Math.max(lSum, rSum) + root.val;
        int rootOrRootWithChildMax = Math.max(root.val, rootWithMaxChildSum);
        int branchesWithRootSum = lSum + rSum + root.val;
        //         Sum update karte waqt dhyan rakho ki maxSumm update hoyega considering all four conditions. Lekin return woh value hoga jo us node ko path ka part ginta hai meaning that the root of the actual maxSum tree is somewhere up in the hierarchy from the current node.
        int maxToRecord = Math.max(rootOrRootWithChildMax, branchesWithRootSum);
        max = Math.max(max, maxToRecord);
        return rootOrRootWithChildMax;
    }
}
```

127. Word Ladder

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> set = new HashSet<>(wordList);
    Queue<String> queue = new LinkedList<>();
    queue.add(beginWord);
    // COUNT NUMBER OF WORDS TRANSFORMED
    int count = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        // FOR ALL WORDS THIS ROUND
        for (int i = 0; i < size; i++) {
            char[] current = queue.poll().toCharArray();
            // TRAVERSE CURRENT WORD
            for (int j = 0; j < current.length; j++) {
                char tmp = current[j];
                // CHANGE ONE LETTER AT A TIME 
                for (char c = 'a'; c <= 'z'; c++) {
                    current[j] = c;
                    String next = new String(current);
                    // WHEN NEXT WORD IS IN THE SET
                    if (set.contains(next)) {
                        if (next.equals(endWord)) return count + 1;
                        queue.add(next);
                        set.remove(next);
                    }
                }
                // HAVE TO UNDO FOR NEXT CHANGE OF LETTER
                current[j] = tmp;
            }
        }
        // THIS ROUND ENDS WITH ONE LETTER CHANGED
        count++;
    }
    return 0;
}
}
```
140. Word Break II

```java
class Solution {
   
public List<String> wordBreak(String s, List<String> wordDict) {
    return DFS(s, new HashSet<String>(wordDict), new HashMap<String, LinkedList<String>>());
}       

// DFS function returns an array including all substrings derived from s.
List<String> DFS(String s, Set<String> wordDict, HashMap<String, LinkedList<String>>map) {
    if (map.containsKey(s)) 
        return map.get(s);
        
    LinkedList<String>res = new LinkedList<String>();     
    if (s.length() == 0) {
        res.add("");
        return res;
    }               
    for (String word : wordDict) {
        if (s.startsWith(word)) {
            List<String>sublist = DFS(s.substring(word.length()), wordDict, map);
            for (String sub : sublist) 
                res.add(word + (sub.isEmpty() ? "" : " ") + sub);               
        }
    }       
    map.put(s, res);
    return res;
}
}
```
149. Max Points on a Line

```java
public class Solution {
    public int maxPoints(Point[] points) {
        if(points.length <= 0) return 0;
        if(points.length <= 2) return points.length;
        int result = 0;
        for(int i = 0; i < points.length; i++){
            HashMap<Double, Integer> hm = new HashMap<Double, Integer>();
            int samex = 1;
            int samep = 0;
            for(int j = 0; j < points.length; j++){
                if(j != i){
                    if((points[j].x == points[i].x) && (points[j].y == points[i].y)){
                        samep++;
                    }
                    if(points[j].x == points[i].x){
                        samex++;
                        continue;
                    }
                    double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);
                    if(hm.containsKey(k)){
                        hm.put(k,hm.get(k) + 1);
                    }else{
                        hm.put(k, 2);
                    }
                    result = Math.max(result, hm.get(k) + samep);
                }
            }
            result = Math.max(result, samex);
        }
        return result;
    }
}
```
212. Word Search II

```java
class Solution {
   public List<String> findWords(char[][] board, String[] words) {
    List<String> res = new ArrayList<>();
    TrieNode root = buildTrie(words);
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            dfs (board, i, j, root, res);
        }
    }
    return res;
}

public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
    char c = board[i][j];
    if (c == '#' || p.next[c - 'a'] == null) return;
    p = p.next[c - 'a'];
    if (p.word != null) {   // found one
        res.add(p.word);
        p.word = null;     // de-duplicate
    }

    board[i][j] = '#';
    if (i > 0) dfs(board, i - 1, j ,p, res); 
    if (j > 0) dfs(board, i, j - 1, p, res);
    if (i < board.length - 1) dfs(board, i + 1, j, p, res); 
    if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); 
    board[i][j] = c;
}

public TrieNode buildTrie(String[] words) {
    TrieNode root = new TrieNode();
    for (String w : words) {
        TrieNode p = root;
        for (char c : w.toCharArray()) {
            int i = c - 'a';
            if (p.next[i] == null) p.next[i] = new TrieNode();
            p = p.next[i];
       }
       p.word = w;
    }
    return root;
}

class TrieNode {
    TrieNode[] next = new TrieNode[26];
    String word;
}
}
```
218. The Skyline Problem

```java
class Solution {
    public List<int[]> getSkyline(int[][] buildings) {
        List<int[]> res = new ArrayList<>();
        List<int[]> height = new ArrayList<>();
        for (int[] building : buildings) {
            // start point has negative height value
            height.add(new int[]{building[0], -building[2]});
            // end point has normal height value
            height.add(new int[]{building[1], building[2]});
        }
        Collections.sort(height, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                if (a[0] == b[0]) {
                    return a[1] - b[1];
                } else {
                    return a[0] - b[0];
                }
            }
        });
        // Use a maxHeap to store possible heights
        // But priority queue does not support remove in lgn time
        // treemap support add, remove, get max in lgn time, so use treemap here
        // key: height, value: number of this height
        TreeMap<Integer, Integer> pq = new TreeMap<>();
        pq.put(0, 1);
        // Before starting, the previous max height is 0;
        int prev = 0;
        // visit all points in order
        for (int[] h : height) {
            // a start point, add height
            if (h[1] < 0) {
                pq.put(-h[1], pq.getOrDefault(-h[1], 0) + 1);
            } else {  // a end point, remove height
                if (pq.get(h[1]) > 1) {
                    pq.put(h[1], pq.get(h[1]) - 1);
                } else {
                    pq.remove(h[1]);
                }
            }
            int cur = pq.lastKey();
            // compare current max height with previous max height, update result and 
            // previous max height if necessary
            if (cur != prev) {
                res.add(new int[]{h[0], cur});
                prev = cur;
            }
        }
        return res;
    }
}
```

239. Sliding Window Maximum
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        //  1. Use a deque to store the indexes and make sure head has the largest number
        //  2. For each incoming element, we first check whether it's bigger than the nums[last element] of dq. If so, continue to remove nums[last element] of dq
        // 3. Check each head element to see if they are >= (end - k + 1) range. If not, remove head
        // 4. If end + 1 >= k, we update the result using nums[deque.peekFirst()] as head is always the big number's index
        if (nums == null || nums.length == 0) {
            return new int[0];
        }
        Deque<Integer> deque = new ArrayDeque<>();
        int index = 0;
        int[] result = new int[nums.length - k + 1];
        
        for (int end = 0; end < nums.length; end++) { 
            int cur = nums[end];
            while (!deque.isEmpty() && nums[deque.peekLast()] < cur) { 
                deque.removeLast();
            }
            while (!deque.isEmpty() && deque.peekFirst() < end - k + 1) { 
                deque.removeFirst();
            }
            deque.addLast(end);
            
            if (end + 1 >= k) { //
                result[index++] = nums[deque.peekFirst()];
            }
        }
        
        return result;
    }
}
```
269. Alien Dictionary

```java
class Solution {
    
    // count the number of parents that a particular node has by adding to the node,
    // need to initialize this before
    public static <T> Map<T, Integer> countParents(Map<T, List<T>> graph) {
        Map<T, Integer> counts = new HashMap<>();
        graph.keySet().forEach(node -> {
            counts.put(node, 0);
        });
        // loop through every node and add to the child node 1 parent
        graph.entrySet().forEach(entry -> {
            for (T node : entry.getValue()) {
                counts.put(node, counts.get(node) + 1);
            }
        });
        return counts;
    }
    
    
    
    // topological sort the list
    public static List<Character> topoSort(Map<Character, List<Character>> graph) {
        // return a list of the topological sorted list
        List<Character> res = new ArrayList<>();
        // make a queue that we will use for our solution
        PriorityQueue<Character> q = new PriorityQueue<>();
        // loop through all nodes and add all nodes that do not have any parent
        Map<Character, Integer> counts = countParents(graph);
        counts.entrySet().forEach(entry -> {
            if (entry.getValue() == 0) {
                q.add(entry.getKey());
            }
        });
        // perform bfs with queue, mostly the same as template bfs
        while (!q.isEmpty()) {
            char node = q.poll();
            // add node to list to keep track of topological order
            res.add(node);
            for (char child : graph.get(node)) {
                // subtract one from every neighbour
                counts.put(child, counts.get(child) - 1);
                // once the number of parents reaches zero you add it to the queue
                if (counts.get(child) == 0) {
                    q.add(child);
                }
            }
        }

        for (int count : counts.values()){
            if (count != 0) {
                return null;
            }
        }
        return res;
    }
    
   public String alienOrder(String[] wordss) {
        List<String> words=new ArrayList<String>();
        for(String word:wordss) words.add(word);
        // init graph
        HashMap<Character, List<Character>> graph = new HashMap<>();
        for (String word : words) {
            for (int i = 0; i < word.length(); i++) {
                char c = word.charAt(i);
                if (!graph.containsKey(c)) {
                    graph.put(c, new ArrayList<>());
                }
            }
        }

        String prev = words.get(0);
        // derive order from adjacent words
        for (int i = 1; i < words.size(); i++) {
            String cur = words.get(i);
            for (int j = 0; j < prev.length() && j < cur.length(); j++) {
                // ignore duplicates
                if (prev.charAt(j) != cur.charAt(j)) {
                    if (!graph.get(prev.charAt(j)).contains(cur.charAt(j))) {
                        graph.get(prev.charAt(j)).add(cur.charAt(j));
                    }
                    break;
                }
            }
            prev = cur;
        }

        List<Character> sorted = topoSort(graph);
        return sorted == null ? ""
                : sorted.stream()
                        .map(String::valueOf)
                        .collect(Collectors.joining());
    }

}
```
295. Find Median from Data Stream

```java
class MedianFinder {

    private PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder());
    private PriorityQueue<Integer> large = new PriorityQueue<>();
    private boolean even = true;

    public double findMedian() {
        if (even)
            return (small.peek() + large.peek()) / 2.0;
        else
            return small.peek();
}

public void addNum(int num) {
    if (even) {
        large.offer(num);
        small.offer(large.poll());
    } else {
        small.offer(num);
        large.offer(small.poll());
    }
    even = !even;
}
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```
297. Serialize and Deserialize Binary Tree

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    private static final String spliter = ",";
    private static final String NN = "X";

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        buildString(root, sb);
        return sb.toString();
    }

    private void buildString(TreeNode node, StringBuilder sb) {
        if (node == null) {
            sb.append(NN).append(spliter);
        } else {
            sb.append(node.val).append(spliter);
            buildString(node.left, sb);
            buildString(node.right,sb);
        }
    }
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        Deque<String> nodes = new LinkedList<>();
        nodes.addAll(Arrays.asList(data.split(spliter)));
        return buildTree(nodes);
    }
    
    private TreeNode buildTree(Deque<String> nodes) {
        String val = nodes.remove();
        if (val.equals(NN)) return null;
        else {
            TreeNode node = new TreeNode(Integer.valueOf(val));
            node.left = buildTree(nodes);
            node.right = buildTree(nodes);
            return node;
        }
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```
329. Longest Increasing Path in a Matrix

```java
class Solution {
    int dp[][];
    public int longestIncreasingPath(int[][] matrix) {
        dp=new int[matrix.length][matrix[0].length];
        
        int[][] dirs={{1,0},{-1,0},{0,1},{0,-1}};
        int max=0;
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                dp[i][j]=-1;
            }
        }
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                max=Integer.max(max, dfs(matrix,i,j,dirs));
            }
        }
        return max;
    }
    
    public int dfs(int[][] matrix, int r, int c, int[][] dirs){
        if(!isValid(r,c,matrix)) return 0;
        if(dp[r][c]!=-1) return dp[r][c];
        int max=1;
        for(int i=0;i<dirs.length;i++){
            int[] dir=dirs[i];
            int newR=r+dir[0];
            int newC=c+dir[1];
            if(isValid(newR,newC,matrix)&&(matrix[r][c]<matrix[newR][newC])){
                //System.out.println(newR+" "+newC+" "+dfs(matrix,newR,newC,path_count+1,dirs));
                max=Integer.max(max,1+dfs(matrix,newR,newC,dirs));
            }
        }
        dp[r][c]=Math.max(max,dp[r][c]);
        return max;
    }
    public boolean isValid(int r, int c, int[][] matrix){
        return r>=0&&c>=0&&r<matrix.length&&c<matrix[0].length;
    }
}
```

	
